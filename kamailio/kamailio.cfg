#!KAMAILIO
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

####### Minimal Kamailio Config for Testing #######

# ----------------- Modules to Load -----------------

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "sanity.so"
loadmodule "siputils.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "permissions.so"   
loadmodule "rtpproxy.so"      
loadmodule "nathelper.so"

# ----------------- Module Parameters -----------------

modparam("rr", "enable_full_lr", 1)
modparam("tm", "failure_reply_mode", 3)
modparam("registrar", "method_filtering", 1)
#modparam("maxfwd", "max_limit", 70)
modparam("usrloc", "db_mode", 0)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 10000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 1)
modparam("tm", "pass_provisional_replies", 1)
modparam("tm", "contacts_avp", "tm_contacts");
modparam("tm", "contact_flows_avp", "tm_contact_flows");

# ----------------- Network Interfaces -----------------

listen=udp:0.0.0.0:5060 advertise 3.85.251.30:5060

# ----------------- Main Routing Logic -----------------

request_route {

    xlog("L_INFO --- New Request: $rm from $si:$sp ---\n");

    # Drop if max forwards exceeded
#    if (!mf_process_maxfwd(10)) {
#        sl_send_reply("483", "Too Many Hops");
#        exit;
#    }

    # Basic sanity checks
    if (!sanity_check("1761", "7")) {
        xlog("Malformed SIP message\n");
        exit;
    }

    # 1. Handle in-dialog requests (ACK, BYE, etc.)
    if (has_totag()) {
        # This loose_route() call is what looks for the Route header!
        if (!loose_route()) {
            # If loose_route fails, the necessary Route header is missing/malformed.
            sl_send_reply("404", "Route Not Found");
            exit;
        }
        route(RELAY);
        exit;
    }

    # Handle registration
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }
	
	# Route INVITE to FS
    if (is_method("INVITE")) {
	record_route();
        route(FS);
        exit;
    }

    # Relay SIP traffic
    if (is_method("OPTIONS|INFO|UPDATE|SUBSCRIBE|NOTIFY")) {
        route(RELAY);
        exit;
    }

    # Everything else blocked
    sl_send_reply("405", "Method Not Allowed");
    exit;
}

# ----------------- Registrar Handling -----------------

route[REGISTRAR] {
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# ----------------- Relay Handling -----------------

route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# ----------------- FS Relay -----------------
route[FS] {
    if (nat_uac_test(6)) {
        fix_nated_contact();
    }

    if (nat_uac_test(6)) {
        fix_nated_sdp("10");
    }

    # Set target FS IP and port
    $du = "sip:54.175.1.251:5060";

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# ----------------- ON REPLY ROUTING LOGIC -----------------
onreply_route {
    # CRITICAL: This ensures the 200 OK sent to the NATed client (the Caller)
    # has the correct Via and Contact headers rewritten to their public IP.
    if (nat_uac_test(6)) {
        # nat_uac_test(6) = Checks if reply is for a NATed client
        # This module changes the Via/Contact headers in the reply.
        setflag(FLT_NATED); // Set a flag if the client is NATed
        fix_nated_contact();
    }
}
