#!KAMAILIO
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

####### Minimal Kamailio Config for Testing #######

# ----------------- Modules to Load -----------------

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "sanity.so"
loadmodule "siputils.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "permissions.so"   
loadmodule "rtpproxy.so"      
loadmodule "nathelper.so"

# ----------------- Module Parameters -----------------

modparam("rr", "enable_full_lr", 1)
modparam("tm", "failure_reply_mode", 3)
modparam("registrar", "method_filtering", 1)
#modparam("maxfwd", "max_limit", 70)
modparam("usrloc", "db_mode", 0)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 10000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 1)
modparam("tm", "pass_provisional_replies", 1)
modparam("tm", "contacts_avp", "tm_contacts");
modparam("tm", "contact_flows_avp", "tm_contact_flows");

# ----------------- Network Interfaces -----------------

listen=udp:0.0.0.0:5060 advertise 3.85.251.30:5060

# ----------------- Main Routing Logic -----------------

request_route {

    xlog("L_INFO --- New Request: $rm from $si:$sp ---\n");

    # Drop if max forwards exceeded
#    if (!mf_process_maxfwd(10)) {
#        sl_send_reply("483", "Too Many Hops");
#        exit;
#    }

    # Basic sanity checks
    if (!sanity_check("1761", "7")) {
        xlog("Malformed SIP message\n");
        exit;
    }

    # 1. Handle in-dialog requests (ACK, BYE, etc.)
    if (has_totag()) {
        # This loose_route() call is what looks for the Route header!
        if (!loose_route()) {
            # If loose_route fails, the necessary Route header is missing/malformed.
            if (is_method("ACK")) {
                xlog("L_INFO --- ACK without Route header, checking transaction ---\n");
                # ACK to 2xx is not part of transaction, route directly to FS
                # ACK to non-2xx is part of transaction, t_relay will handle it
                if (t_check_trans()) {
                    xlog("L_INFO --- ACK is part of transaction, using t_relay ---\n");
                    if (nat_uac_test(6)) {
                        fix_nated_contact();
                    }
                    # Only fix SDP if message has body (ACK to non-2xx might have body)
                    if (has_body() && nat_uac_test(6)) {
                        fix_nated_sdp("10");
                    }
                    route(RELAY);
                    exit;
                } else {
                    # ACK to 2xx - route directly to FreeSWITCH (no body, no NAT fixes needed)
                    xlog("L_INFO --- ACK to 2xx, routing directly to FreeSWITCH ---\n");
                    route(FS);
                    exit;
                }
            }
            
            # Handle BYE without Route header
            if (is_method("BYE")) {
                xlog("L_INFO --- BYE without Route header, checking transaction ---\n");
                if (t_check_trans()) {
                    xlog("L_INFO --- BYE is part of transaction, using t_relay ---\n");
                    if (nat_uac_test(6)) {
                        fix_nated_contact();
                    }
                    if (has_body() && nat_uac_test(6)) {
                        fix_nated_sdp("10");
                    }
                    route(RELAY);
                    exit;
                } else {
                    # BYE without transaction - route directly to FreeSWITCH
                    xlog("L_INFO --- BYE without transaction, routing directly to FreeSWITCH ---\n");
                    route(FS);
                    exit;
                }
            }

            sl_send_reply("404", "Route Not Found");
            exit;
        }
        
        xlog("L_INFO --- inside loose_route() ---\n");

        route(RELAY);
        exit;
    }

    # Handle registration
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }
	
	# Route INVITE to FS
    if (is_method("INVITE")) {
	record_route();
        route(FS);
        exit;
    }

    # Relay SIP traffic
    if (is_method("OPTIONS|INFO|UPDATE|SUBSCRIBE|NOTIFY")) {
        route(RELAY);
        exit;
    }

    # Everything else blocked
    sl_send_reply("405", "Method Not Allowed");
    exit;
}

# ----------------- Registrar Handling -----------------

route[REGISTRAR] {
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# ----------------- Relay Handling -----------------

route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# ----------------- FS Relay -----------------
route[FS] {
    if (nat_uac_test(6)) {
        fix_nated_contact();
    }

    if (nat_uac_test(6)) {
        fix_nated_sdp("10");
    }

    # Set target FS IP and port
    $du = "sip:54.175.1.251:5060";

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# ----------------- ON REPLY ROUTING LOGIC -----------------
onreply_route {
    # CRITICAL: This ensures the 200 OK sent to the NATed client (the Caller)
    # has the correct Via and Contact headers rewritten to their public IP.
    if (nat_uac_test(6)) {
        # nat_uac_test(6) = Checks if reply is for a NATed client
        # This module changes the Via/Contact headers in the reply.
        fix_nated_contact();
    }
}
